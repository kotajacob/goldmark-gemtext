package gemtext

import "regexp"

// HR is the default HorizontalRule string used in NewConfig.
const HR = ""

// Config has configurations for the gemini renderer.
type Config struct {
	HeadingLink    HeadingLink
	HeadingSpace   HeadingSpace
	ParagraphLink  ParagraphLink
	Emphasis       Emphasis
	Strikethrough  Strikethrough
	CodeSpan       CodeSpan
	HorizontalRule string
	LinkReplacers  []LinkReplacer
}

// NewConfig returns a new Config with defaults.
func NewConfig() *Config {
	return &Config{
		HeadingLink:    HeadingLinkAuto,
		HeadingSpace:   HeadingSpaceDouble,
		ParagraphLink:  ParagraphLinkBelow,
		Emphasis:       EmphasisOff,
		Strikethrough:  StrikethroughOff,
		CodeSpan:       CodeSpanOff,
		HorizontalRule: HR,
		LinkReplacers:  []LinkReplacer{},
	}
}

// An Option interface sets options for gemini renderers.
type Option interface {
	// Replace the current configuration.
	SetConfig(*Config)
}

// A function that implements the Option interface.
type OptionFunc func(*Config)

// SetConfig replaces the current configuration.
func (o OptionFunc) SetConfig(c *Config) {
	o(c)
}

// Pass a completely new config as an option.
func WithConfig(config *Config) Option {
	return OptionFunc(func(c *Config) {
		*c = *config
	})
}

// Set HeadingLink mode.
func WithHeadingLink(val HeadingLink) Option {
	return OptionFunc(func(c *Config) {
		c.HeadingLink = val
	})
}

// HeadingLink is an emun config option that controls how links in headings are
// treated.
type HeadingLink uint8

const (
	// Ignore links in headings; writing the label of the link in its place.
	HeadingLinkOff HeadingLink = iota
	// If the heading contains only links, use the first link instead of
	// printing a heading. Otherwise print a heading, ignoring links.
	HeadingLinkAuto
	// Print all links below heading.
	HeadingLinkBelow
)

// Set HeadingSpace mode.
func WithHeadingSpace(val HeadingSpace) Option {
	return OptionFunc(func(c *Config) {
		c.HeadingSpace = val
	})
}

// HeadingSpace is an emun config option that controls how many newline
// characters are entered after a heading.
type HeadingSpace uint8

const (
	// Enter just a single newline after the heading. Content will be smacked
	// up right below it.
	HeadingSpaceSingle HeadingSpace = iota
	// Enter two newlines below the heading. Giving content some nice breathing
	// room.
	HeadingSpaceDouble
)

// Set ParagraphLink mode.
func WithParagraphLink(val ParagraphLink) Option {
	return OptionFunc(func(c *Config) {
		c.ParagraphLink = val
	})
}

// ParagraphLink is an enum config option that controls how links in
// paragraphs are treated.
type ParagraphLink uint8

const (
	// Ignore links in paragraphs; writing the label of the link in its place.
	ParagraphLinkOff ParagraphLink = iota
	// Print links below paragraph.
	ParagraphLinkBelow
)

// Set Emphasis mode.
func WithEmphasis(val Emphasis) Option {
	return OptionFunc(func(c *Config) {
		c.Emphasis = val
	})
}

// Emphasis is an enum config option that controls how markdown emphasis (bold
// and italics) are treated.
type Emphasis uint8

const (
	// Strip out markdown emphasis symbols (* and _)
	EmphasisOff Emphasis = iota
	// Print markdown emphasis symbols for italics and bold (** and _)
	EmphasisMarkdown
	// Print markdown emphasis using 𝘄𝗲𝗶𝗿𝗱 𝘶𝘯𝘪𝘤𝘰𝘥𝘦 hacks.
	// NOTE: The current generation of screenreaders are unable to handle this
	// hack. The symbols are meant for mathematics and are pronounced
	// individually as such. As a result you should ONLY use this option if
	// you're providing an alternative accessible copy of your document.
	EmphasisUnicode
)

// Set Strikethrough mode.
func WithStrikethrough(val Strikethrough) Option {
	return OptionFunc(func(c *Config) {
		c.Strikethrough = val
	})
}

// Strikethrough is an enum config option that controls how markdown
// strikethrough (per the github markdown extension) is treated.
type Strikethrough uint8

const (
	// Strip out markdown strikethrough symbols (~~).
	StrikethroughOff Strikethrough = iota
	// Print markdown strikethrough symbols (~~).
	StrikethroughMarkdown
	// Print strikethrough using 𝘄𝗲𝗶𝗿𝗱 𝘶𝘯𝘪𝘤𝘰𝘥𝘦 hacks.
	// NOTE: The current generation of screenreaders are unable to handle this
	// hack. The symbols are generated by manipulating diacritical marks which
	// traditionally influence pronunciation. As a result you should ONLY use
	// this option if you're providing an alternative accessible copy of your
	// document.
	StrikethroughUnicode
)

// Set CodeSpan mode.
func WithCodeSpan(val CodeSpan) Option {
	return OptionFunc(func(c *Config) {
		c.CodeSpan = val
	})
}

// CodeSpan is an enum config option that controls how markdown codespan is
// treated.
type CodeSpan uint8

const (
	// Strip out markdown codespan symbols.
	CodeSpanOff CodeSpan = iota
	// Print markdown codespan symbols.
	CodeSpanMarkdown
)

// Set HorizontalRule string.
func WithHorizontalRule(val string) Option {
	return OptionFunc(func(c *Config) {
		c.HorizontalRule = val
	})
}

// LinkReplacer is used to modify links with regular expressions. This could be
// used to change links that end in .md to .gmi.
type LinkReplacer struct {
	Type        LinkType
	Regex       *regexp.Regexp
	Replacement string
}

// LinkType is an enum describing a type of markdown link. A LinkReplacer can be
// applied to one or multiple link types. This makes it easy to have a regular
// expression only apply to wiki style links, but ignore traditional markdown
// links and auto links for example.
type LinkType uint8

const (
	// LinkMarkdown is a traditional markdown link using brackets and
	// parenthesis.
	LinkMarkdown LinkType = iota
	// LinkAuto is a markdown link that was automatically detected with
	// heuristics. This type of link must be supported by your goldmark parser
	// to be used. There's an official extension that adds it.
	LinkAuto
	// LinkWiki is a wiki style link. This is a non-standard, but popular syntax
	// used in some wiki's that would otherwise be compliant markdown. I wrote a
	// goldmark extension to detect this type of link:
	// https://git.sr.ht/~kota/goldmark-wiki
	LinkWiki
	// LinkImage is a markdown image link.
	LinkImage
)

// Set LinkReplacers.
func WithLinkReplacers(r []LinkReplacer) Option {
	return OptionFunc(func(c *Config) {
		c.LinkReplacers = r
	})
}
